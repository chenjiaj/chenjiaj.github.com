layout: w
title: 清晰理解js闭包
date: 2016-08-24 16:37:22
categories: 'js'
tags: js
---
对于闭包一直是一知半解的，有时候知道使用了闭包，但是不能很好的讲述出来，于是看了一下相关资料，整理一下，便于更好的理解和描述。

### 一、什么是闭包

定义：闭包是指可以包含自由（未绑定到特定对象）变量的代码块；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。“闭包” 一词来源于以下两者的结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域）。在PHP、Scala、Scheme、Common Lisp、Smalltalk、Groovy、JavaScript、Ruby、 Python、Go、Lua、objective c、swift 以及Java（Java8及以上）等语言中都能找到对闭包不同程度的支持。

专业定义对应我来说比较抽象，很难理解和记住。就我自己的理解来说<b>"闭包就是函数内部的函数，能够读取外部函数的变量，能够访问他被创建时所处的上下文环境"。</b>

### 二、闭包的作用
1.可以读取外部函数的变量，并让这些变量始终保持在内存中
2.便于模块化开发，减少全局变量。让开发过程中不必担心变量或函数重名的问题，避免污染全局变量，让全局变量专注于通用。

### 三、闭包存在的问题

闭包会使内部变量被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页性能问题，在IE中造成内存泄漏。
解决方法：在退出函数时，将不使用的的局部变量全部删除

### 四、闭包的应用实例

#### 1.闭包只能获取函数中任何变量最新的值
	
	闭包只能获取函数中任何变量最新的值（通常是最后一个值），闭包保存的是整个变量对象，而不是某个特殊的变量

    function createFunc() {
	var result = new Array();
	for (var i = 0; i < 10; i++) {
		result[i] = function() {
			return i;
		}
	}
	return result;
    }

这个函数会返回一个函数数组，表面上每个函数都应该返回自己的索引值，实际上每个函数返回的都是10，因为每个函数都是引用的变量i，当createFunc执行完后，i就变成了10。

可以通过创建一个匿名函数，强制让闭包行为符合预期,如下：

    function createFunc() {
	var result = new Array();
	for (var i = 0; i < 10; i++) {
		result[i] = (function(e) {
			return function() {
				return e;
			}
		})(i);

	}
	return result;
    }

通过立即执行一个匿名函数，并把变量i传给匿名函数，而匿名函数内部又创建了一个访问num的闭包

#### 2.关于this对象

在闭包中使用this对象也可能导致一些问题，this对象是在运行是基于函数的执行环境绑定的；在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。不过，匿名函数的执行环境具有全局性，因此其this对象通常指向window。但有时候由于编写闭包的方式不同，这一点可能不会那么明显。

    var name = "The Window";
    var object = {　　
	name: "My Object",
	　　getNameFunc: function() {　　　　
		return function() {　　　　　　
			return this.name;　　　　
		};　　
	}
    };
    alert(object.getNameFunc()()); //“The Window”,在非严格模式下

如果想让他访问到object对象的属性，可以在闭包的包含函数中申明一个变量保存对象的this

    var name = "The Window";　　
    var object = {　　　　
	name: "My Object",
	getNameFunc: function() {　　　　　　
		var that = this;　　　　　　
		return function() {　　　　　　　　
			return that.name;　　　　　　
		};　　　　
	}　　
    };　　
    alert(object.getNameFunc()());

#### 3.内存泄漏问题

由于IE9之前的版本对JScript对象和COM对象使用不同的垃圾收集例程，因此闭包在IE的这些版本中会导致一些特殊的问题。具体来说，如果闭包的作用域中保存着一个HTML元素，那么就意味着该元素将无法被销毁

    function assignHandle(){
        var element = document.getElementById('someElement');
        element.onclick = function(){
            alert(element.id);
        }
    }

如果浏览器采用的引用计数的垃圾处理机制，那么以上例子会有以下问题：
由于匿名函数保存了一个对assignHandle()的活动对象引用，因此就会导致无法减少element的引用。只要匿名函数存在，element的引用数至少也是1，因此它所占用的内存就永远不会被回收。

    function assignHandle(){
        var element = document.getElementById('someElement');
        var id = element.id;
        element.onclick = function(){
            alert(id);
        }
      element = null;
    }

闭包不直接引用element，包含函数的活动对象中也仍然会保存这个引用。隐藏必须报element变量设置成null,这样才能够解除对DOM对象的引用，顺利地减少其引用次数，确保正常收回其占用的内存。